#pragma once

#include "uvgrtp/util.hh"

#ifdef _WIN32
#include <winsock2.h>
#include <mswsock.h>
#include <inaddr.h>
#else
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <sys/uio.h>
#endif

#include <vector>
#include <string>

#ifdef _WIN32
typedef SOCKET socket_t;
#else
typedef int socket_t;
#endif

namespace uvgrtp {

#ifdef _WIN32
    typedef unsigned int socklen_t;
#endif

#if defined(UVGRTP_HAVE_SENDMSG) && !defined(UVGRTP_HAVE_SENDMMSG)
    struct mmsghdr {
        struct msghdr msg_hdr;
        unsigned int msg_len;
    };
    static inline
    int sendmmsg(int sockfd, struct mmsghdr *msgvec, unsigned int vlen,
        int flags)
    {
        ssize_t n = 0;
        for (unsigned int i = 0; i < vlen; i++) {
            ssize_t ret = sendmsg(sockfd, &msgvec[i].msg_hdr, flags);
            if (ret < 0)
                break;
            n += ret;
        }
        if (n == 0)
            return -1;
        return int(n);
    }
#endif

    const int MAX_BUFFER_COUNT = 256;

    /* Vector of buffers that contain a full RTP frame */
    typedef std::vector<std::pair<size_t, uint8_t *>> buf_vec;

    /* Vector of RTP frames constructed from buf_vec entries */
    typedef std::vector<std::vector<std::pair<size_t, uint8_t *>>> pkt_vec;

    typedef rtp_error_t (*packet_handler_vec)(void *, buf_vec&);

    struct socket_packet_handler {
        void *arg = nullptr;
        packet_handler_vec handler = nullptr;
    };

    class socket {
        public:
            socket(int rce_flags);
            ~socket();

            /* Create socket using "family", "type" and "protocol"
             *
             * NOTE: Only family AF_INET (ie. IPv4) is supported
             *
             * Return RTP_OK on success
             * return RTP_SOCKET_ERROR if creating the socket failed */
            rtp_error_t init(short family, int type, int protocol);

            /* Same as bind(2), assigns an address for the underlying socket object
             *
             * Return RTP_OK on success
             * Return RTP_BIND_ERROR if the bind failed */
            rtp_error_t bind(short family, unsigned host, short port);
            rtp_error_t bind(sockaddr_in& local_address);

            /* Same as setsockopt(2), used to manipulate the underlying socket object
             *
             * Return RTP_OK on success
             * Return RTP_GENERIC_ERROR if setsockopt failed */
            rtp_error_t setsockopt(int level, int optname, const void *optval, socklen_t optlen);

            /* Same as send(2), send message to remote with send_flags
             * This function uses the internal addr_ object as remote address so it MUST be set
             *
             * It is possible to combine multiple buffers and send them as one RTP frame by calling
             * the sendto() with a vector containing the buffers and their lengths
             *
             * Write the amount of bytes sent to "bytes_sent" if it's not NULL
             *
             * Return RTP_OK on success and write the amount of bytes sent to "bytes_sent"
             * Return RTP_SEND_ERROR on error and set "bytes_sent" to -1 */
            rtp_error_t sendto(uint8_t *buf, size_t buf_len, int send_flags);
            rtp_error_t sendto(uint8_t *buf, size_t buf_len, int send_flags, int *bytes_sent);
            rtp_error_t sendto(buf_vec& buffers, int send_flags);
            rtp_error_t sendto(buf_vec& buffers, int send_flags, int *bytes_sent);
            rtp_error_t sendto(pkt_vec& buffers, int send_flags);
            rtp_error_t sendto(pkt_vec& buffers, int send_flags, int *bytes_sent);

            /* Same as sendto() but the remote address given as parameter */
            rtp_error_t sendto(sockaddr_in& addr, uint8_t *buf, size_t buf_len, int send_flags);
            rtp_error_t sendto(sockaddr_in& addr, uint8_t *buf, size_t buf_len, int send_flags, int *bytes_sent);
            rtp_error_t sendto(sockaddr_in& addr, buf_vec& buffers, int send_flags);
            rtp_error_t sendto(sockaddr_in& addr, buf_vec& buffers, int send_flags, int *bytes_sent);
            rtp_error_t sendto(sockaddr_in& addr, pkt_vec& buffers, int send_flags);
            rtp_error_t sendto(sockaddr_in& addr, pkt_vec& buffers, int send_flags, int *bytes_sent);

            /* Same as recv(2), receives a message from socket (remote address not known)
             *
             * Write the amount of bytes read to "bytes_read" if it's not NULL
             *
             * Return RTP_OK on success and write the amount of bytes received to "bytes_read"
             * Return RTP_INTERRUPTED if the call was interrupted due to timeout and set "bytes_sent" to 0
             * Return RTP_GENERIC_ERROR on error and set "bytes_sent" to -1 */
            rtp_error_t recv(uint8_t *buf, size_t buf_len, int recv_flags);
            rtp_error_t recv(uint8_t *buf, size_t buf_len, int recv_flags, int *bytes_read);

            /* Same as recvfrom(2), receives a message from remote
             *
             * Write the sender address to "sender" if it's not NULL
             * Write the amount of bytes read to "bytes_read" if it's not NULL
             *
             * Return RTP_OK on success and write the amount of bytes sent to "bytes_sent"
             * Return RTP_INTERRUPTED if the call was interrupted due to timeout and set "bytes_sent" to 0
             * Return RTP_GENERIC_ERROR on error and set "bytes_sent" to -1 */
            rtp_error_t recvfrom(uint8_t *buf, size_t buf_len, int recv_flags, sockaddr_in *sender, int *bytes_read);
            rtp_error_t recvfrom(uint8_t *buf, size_t buf_len, int recv_flags, sockaddr_in *sender);
            rtp_error_t recvfrom(uint8_t *buf, size_t buf_len, int recv_flags, int *bytes_read);
            rtp_error_t recvfrom(uint8_t *buf, size_t buf_len, int recv_flags);

            /* Create sockaddr_in object using the provided information
             * NOTE: "family" must be AF_INET */
            sockaddr_in create_sockaddr(short family, unsigned host, short port) const;

            /* Create sockaddr_in object using the provided information
             * NOTE: "family" must be AF_INET */
            sockaddr_in create_sockaddr(short family, std::string host, short port) const;

            std::string get_socket_path_string() const;

            std::string sockaddr_to_string(const sockaddr_in& addr) const;

            /* Get reference to the actual socket object */
            socket_t& get_raw_socket();

            /* Initialize the private "addr_" object with "addr"
             * This is used when calling send() */
            void set_sockaddr(sockaddr_in addr);

            /* Get the out address for the socket if it exists */
            sockaddr_in& get_out_address();

            /* Install a packet handler for vector-based send operations.
             *
             * This handler allows the caller to inject extra functionality to the send operation
             * without polluting src/socket.cc with unrelated code
             * (such as collecting RTCP session statistics info or encrypting a packet)
             *
             * "arg" is an optional parameter that can be passed to the handler when it's called */
            rtp_error_t install_handler(void *arg, packet_handler_vec handler);

            /* Enable read ECN, get ECN-Bit from IP-Header on incoming packets */
            rtp_error_t set_ecn_read(short address_family);

            /* Enable sent ECN, sets IP-Header ECN-Bit in outgoing packets */
            rtp_error_t set_ecn_send(short address_family, unsigned long ecn_bit);

            /*
             * SendTo socket, writes data to the socket and sets given ECN-Bit on outgoing traffic
             * 0, 3 are forbidden
             * 1: ECN Capable Transport(1), ECT(1)
             * 2: ECN Capable Transport(0), ECT(0)
             */
            rtp_error_t sendto(buf_vec& buffers, int send_flags, unsigned long ecn_bit);
            rtp_error_t sendto(pkt_vec& buffers, int send_flags, unsigned long ecn_bit);

            /*
            * RecvFrom socket, writes buffer with received data and returns additional the ECN-Bit from IP-Header as int
            * 0: Not ECN-Capable Transport, Not-ECT
            * 1: ECN Capable Transport(1), ECT(1)
            * 2: ECN Capable Transport(0), ECT(0)
            * 3: Congestion Experienced, CE
            */
            rtp_error_t recvfrom(uint8_t *buf, size_t buf_len, int recv_flags, int *bytes_read, int &ecn_bit);


        private:

            /* helper function for sending UPD packets, see documentation for sendto() above */
            rtp_error_t __sendto(sockaddr_in& addr, uint8_t *buf, size_t buf_len, int send_flags, int *bytes_sent);
            rtp_error_t __recv(uint8_t *buf, size_t buf_len, int recv_flags, int *bytes_read);
            rtp_error_t __recvfrom(uint8_t *buf, size_t buf_len, int recv_flags, sockaddr_in *sender, int *bytes_read);

            /* __sendtov() does the same as __sendto but it combines multiple buffers into one frame and sends them */
            rtp_error_t __sendtov(sockaddr_in& addr, buf_vec& buffers, int send_flags, int *bytes_sent);
            rtp_error_t __sendtov(sockaddr_in& addr, uvgrtp::pkt_vec& buffers, int send_flags, int *bytes_sent);

            rtp_error_t __recvfrom(uint8_t *buf, size_t buf_len, int recv_flags, sockaddr_in *sender, int *bytes_read, int &ecn_bit);
            rtp_error_t __sendtov(sockaddr_in& addr, buf_vec& buffers, int send_flags, int *bytes_sent, unsigned long ecn_bit);
            rtp_error_t __sendtov(sockaddr_in& addr, uvgrtp::pkt_vec& buffers, int send_flags, int *bytes_sent, unsigned long ecn_bit);

            socket_t socket_;
            sockaddr_in remote_address_;
            sockaddr_in local_address_;
            int rce_flags_;

            /* __sendto() calls these handlers in order before sending the packet */
            std::vector<socket_packet_handler> buf_handlers_;

            /* __sendtov() calls these handlers in order before sending the packet */
            std::vector<socket_packet_handler> vec_handlers_;

#ifndef NDEBUG
            uint64_t sent_packets_ = 0;
            uint64_t received_packets_ = 0;
#endif // !NDEBUG

#ifdef _WIN32
            WSABUF buffers_[MAX_BUFFER_COUNT];
#else
            struct mmsghdr header_;
            struct iovec   chunks_[MAX_BUFFER_COUNT];
#endif
    };
}

namespace uvg_rtp = uvgrtp;
